## Билет 30 "Стратегии хранения и владения объектами, невладеющие `span/string_view`, `unique_ptr`"
Автор: Илья Онофрийчук

## Как передавать параметры в функции

#### По значению:
Практически всегда параметры передаются по значению, `&&` и умные указатели нужны редко. 
Например, рассмотрим функцию, которая не хочет портить ничего из того, что ей передали:
```cpp
void foo(vector<int> foo_data) { sort(foo_data.begin(), foo_data.end(); .. };
```
Удобно тем, что если мы в какой-то момент, захотим с оптимизировать и сказать, что данные, которые мы передаём в функцию, нам больше не нужны, то достаточно будет их просто замувать.
```cpp
int main() {
    vector<int> data = {1, 2, 3, 4, 5};
    foo(data);  // Тут скопируем, вектор ещё нужен.
    data.emplace_back(6);  // {1, 2, 3, 4, 5, 6}
    foo(std::move(data));  // Разрешили не копировать.
    data.clear();  // Вектор мог остаться непустым, не определено moved-from.
}
```

#### Параметры только для чтения, только для записи:
* Если нам вcегда передают объект, а мы его только читаем:
    ```cpp
    void printVector(const vector<int> &data);
    ```
* Если иногда не передают — std::optional (не указатель!):
    ```cpp
    void maybePrintVector(const std::optional<vector<int>> &data);
    ```
* Если нам всегда нужно передать наружу объект (не указатель!):
    ```cpp
    void readAndAppendToVector(vector<int> &data);
    ```
    Осторожно: а что, если data исходно непуст? Тогда неясно куда записываются данные или что происходит со старыми. Верните по значению или задокументируйте.

* Если пользователь не всегда хочет ответ — указатель.
    ```cpp
    void readAndMaybeAppendToVector(vector<int> *const data);
    ```

#### Rvalue-ссылки в параметрах:
* Не нужно, если объект умеет только `move` (например, `unique_ptr`). Следующие два случа компилируются абсолютно одинакого:
    ```cpp
    void foo(unique_ptr<Foo> &&x);
    ```
    ```cpp
    void foo(unique_ptr<Foo> x);
    ```
    ```cpp
    unique_ptr<Foo> bar;
    foo(bar);             // Не скомпилируется в обоих случаях.
    foo(get_bar());       // Скомпилируется в обоих случаях.
    foo(std::move(bar));  // Скомпилируется в обоих случаях.
    ```
* Если объект можно копировать, то обычно rvalue ссылки не нужны. Если же вы в данном случае из написали, то возможно вы нарушили ожидания у большинства C++ программистов.
    ```cpp
    void foo(Foo &&x);
    Foo bar;
    foo(bar);             // Не компилируется.
    foo(Foo(bar));        // Надо явно копировать, но так не принято.
    foo(std::move(bar));  // Явно мувать можно всегда.
    ```
* Иногда `&&` нужно для оптимизаций или move-конструкторов:
    ```cpp
    void push_back(const T&);
    void push_back(T&&);
    ```


#### По умным указателям:

Умный указатель — пара `(данные, владение)`. В параметрах — только если нам важно, как именно им владеет вызвавший. Обычно неважно.

* `const unique_ptr<T>&` — лучше заменить на `T&` (const явно исчез).
* `unique_ptr<T>&` — если пишем `swap` `unique_ptr`-ов, то нужно; в других случаях почти никогда не используется
* `const shared_ptr<T>&` — почти никогда
* `shared_ptr<T>&` — почти никогда

Примеры умных указателей в парметрах:

* Если надо явно передать функции владение объектом, который не хочется копировать/перемещать, который мы выделили на куче и завернули в `unique_ptr` и мы хотим передать владение, то стоит использовать `unique_ptr`:
    ```cpp
    void passToAnotherProcessAndForget(std::unique_ptr<SomeData> iOwnItNow);
    ```
* Пусть у нас есть оконный менеджер и в нём есть окошки. Окошко нельзя ни копировать, ни перемещать, поэтому мы создали его один раз и везде передаём на него `shared_ptr`-ы. 
    ```cpp
    // Функция хочет скопировать владение `window` куда-то ещё.
    void addToAnotherDesktop(shared_ptr<Window> window) {  // shared_ptr по значению.
        recentlyMovedWindows.emplace_back(window);
        myWindows.emplace_back(std::move(window));
    }
    ```
* Пусть у нас есть бинарное дерево и мы пишем конструктор для его нодов.
 
    Конструктор должен выглядеть следующим образом:
    ```cpp
    Node(Node left_, Node right_)
        : left(make_unique<Node>(std::move(left_))), .... {}
    ```
    Конструктор от `unique_ptr` появляется только с целью оптимизиции:
    ```cpp
    // Оптимизация: всегда оборачиваем в `unique_ptr`, давайте сразу его возьмём.
    Node(unique_ptr<Node> left_, unique_ptr<Node> right_)  // Без &&
    : left(std::move(left_)), right(std::move(right_)) {}
    ```
## Как возвращать значения

Практически всегда возвращать нужно по значению, это самый простой и безопасный способ.

Возврат по ссылке происходит реже, при этом важно следить за тем, что объект, на который возвращается ссылка должен жить и после выхода из функции. Обычно так возвращаются параметры функции, которые мы приняли по ссылке.

Возврат по умным указателям происходит ещё реже. 

Пример с `unique_ptr`: функция возвращает владение объектом:
```cpp
std::unique_ptr<SomeData> readFromAnotherProcess();
```


## Особенности умных указателей для массивов
Для массивов умные указатели следует использовать следующим образом:
```cpp
// квадратные скобки в параметре шаблона
std::unique_ptr<int[]> ptr(new int[10]); 
std::shared_ptr<int[]> ptr(new int[10]); 

std::make_unique<int[]>(10);
std::make_shared<int[]>(10);
```
Это нужно для того, чтобы удаление происходило правильно, с помощью верного `delete[]`. Пример UB:
```cpp
std::unique_ptr<int> ptr(new int[10])
```
В данном случае UB так как массив выделился с помощью `new[]`, а удаляться будет с помощью `delete`

Более хорошая идея -- использовать просто `std::vector`.
## `string_view`, `span`, когда использовать 
Пусть мы хотим написать функцию `print_line` и у нас есть два варианта, как принимать строку:
```cpp
void print_line(const char *);        // 1
void print_line(const std::string&);  // 2
```
Если мы используем первый вариант, то чтобы передать в `print_line` `std::string`, нужно воспользоваться методом `c_str()`. Если же мы используем второй вариант, то при вызове `print_line("123")` будет создаваться `std::string`, то есть будет происходить лишнее выделение на куче.

Решение проблемы: принимать `std::string_view`.

 `string_view` используется для ***невладеющего доступа*** к отрезкам строки.  
```cpp
struct string_view {  // C++17
    const char *data; size_t length;
    string_view substr(size_t pos = 0, size_t count = npos) const;
    ...
};
```
Многое методы из `string` есть и у `string_view`. Также есть возможность получить у `string_view` подстроку без каких-либо изменений памяти (просто создаётся новый `string_view`).

Начиная с C++20 появился `span`. Он аналогичен `string_view`, но работает с произвольными типами.
```cpp
template<typename T>
struct span {  // C++20
    const T *data; size_t length; 
    ...
}
```
Пример использования `spаn`: Если не понятно принимать в функцию константный вектор или `T*`, наверно стоит принимать `span`.

С помощью `string_view` пишется человеческий `split`, который работает без лишних копирований. 
```cpp
std::vector<std::string_view> split(std::string_view str, std::string_view sep);
```

Если нужно получить строчку и только на чтение стоит использовать `string_view`.

## `unique_ptr` для единоличного владения
`unique_ptr` обычно используется если у нас есть рекурсия в том, что надо хранить, или нужно передовать владение объектом, но владелец всегда один. Например, при хранении дерева:
```cpp
struct SearchTreeNode {
    std::unique_ptr<SearchTreeNode> left, right;
    int key; std::string value;
};
```
Ещё и деструктор писать не надо, так как при удалении родителя, автоматически вызовутся деструкторы `left` и `right`.

Если мы что-то выделяем на стеке, то `unique_ptr` обычно совершенно не нужен. 

`unique_ptr` занимает столько же места, сколько обычный указатель.

Можно указать свой функтор удаления (вроде `fclose`), но в случае файлов лучше полностью написать RAII-обёртку (вроде `istream`/`ostream`).

Также у `unique_ptr` существуют методы для совместимости с C:
* Можно узнать значение указателя. При этом владение всё ещё остаётся у `unique_ptr`, поэтому если в блоке ниже вызвать `delete` у `ptr2`, то произойдёт double free.
```cpp 
{
    std::unique_ptr<SomeData> ptr = ....;
    SomeData *ptr2 = ptr.get();
}  // unique_ptr сам вызовет delete
```
* Можно вытащить владение указателя. `unique_ptr` в данном случае перестаёт владеть объектом, поэтому нужно самостоятельно очистить память.
```cpp
{
    std::unique_ptr<SomeData> ptr = ....;
    SomeData *ptr2 = ptr.release();
}  // утечка
```
## Необходимость `make_unique`
`make_unique` нужен для того, чтобы не разделять момент создания объекта и передачи управления в умный указатель. 
```cpp
foo(unique_ptr<Foo>(new Foo), unique_ptr<Bar>(new Bar));
```
До C++17 компилятор мог сначала выполнить все new, а потом все конструкторы. Поэтому если компилятор сначала вызовет `new Foo`, затем `new Bar` и только потом начнёт оборачивать чистые указатели в `unique_ptr`, то если `new Bar` кинет исключение, произойдёт утечка (утекла память выделившаяся при вызове `new Foo`).

`make_unique` решает эту проблему:
```cpp
foo(make_unique<Foo>(), make_unique<Bar>());
```

