## Билет 20 "Ручное управление временем жизни объектов и массивов объектов"
Автор: Денис Филиппов

* Placement new обязателен перед использованием объекта в куске памяти (reinterpret_cast не начинает жизнь), явный вызов деструктора

  * Проблема: может не быть `T()`.  Например, у `Employee` (`Developer`, `SalesManager`), есть конструктор только от имени, возраста и т.п. Тогда `new T[10]` не сработает.

  * Надо сначала выделить кусок памяти, а потом руками вызывать конструкторы и деструкторы. После этого сделать placement new -- создание элемента с помощью оператора `new`, при этом память не будет выделяться, а будет браться по переданному указателю (см. в примере). Важно: обязательно делать placement new, без него объект не существует, вызов конструктора обязателен, просто сделать `reinterpret_cast` недостаточно (даже если это тривиальный тип --`int` и т.п.).

  * После окончания работы с объектом нужно обязательно вручную вызвать деструктор для всех объектов, созданных с помощью placement new (см. пример). После чего нужно удалить память, выделенную изначально под все объекты.

   ``` C++
    #include <memory> // Чтобы не было ошибки "no matching function to call to 'operator new(sizetype, void*&)`"
    struct Foo { Foo(int) {} };
    int main() {
        void *data = aligned_alloc(alignof(Foo), sizeof(Foo) * 3);  // Или malloc(sizeof(Foo) * 3)
                                                                    // или new char[sizeof(Foo) * 3]
        Foo *a = new (data) Foo(10);  // placement new
        Foo *b = new (static_cast<char*>(data) + sizeof(Foo)) Foo(20);
        Foo *c = new (static_cast<char*>(data) + sizeof(Foo) * 2) Foo(30);
        c->~Foo(); // Явный вызов деструктора.
        b->~Foo();
        a->~Foo();
        std::free(data);
    }
    ```

* Для большинства объектов хватает (по выравниванию) выделить память через `new char[]`

  * Выравнивание -- требование, по которому указатель на выделенную память делится на какое-то число. Чаще всего это нужно, чтобы соблюдать требования процессора и т.п., в общем техническое требование.

  * В большинстве случаев хватает хватает выделения памяти с помощью `new char[]`,там выравнивание равно `max_align_t == 8` либо `16`обычно (либо `malloc(...)`, но мы вроде как на плюсах прогаем).

* `aligned_alloc` и `free` для объектов с большим требованием на выравнивание

  * Бывают ситуации, когда выравнивание типа очень большое. В таких случаях используют `std::aligned_alloc(std::size_t aligment /* выравнивание */, std::size_t size /* размер памяти для выделения */)`. `aligment` можно получить с помощью оператора (не функция) `alignof(Foo)` (без `std::`).

  * Освобождение выделенной памяти осуществляется с помощью `std::free`.

* Трудности с обработкой исключений при управлении массивом объектов, `uninitialized_copy` и схожие функции.

  * Всё выше указанное классно работает, когда мы выделяем память под один объект. Когда их больше, начинаются трудности с обработкой исключений. С одним элементом можно легко поймать исключение, обработать его, т.к. тут либо `new char[]` не сработал (тут вообще ничего делать не надо, память не выделилась, объект не создался), либо конструктор выкинул исключение (объект не создался, но нужно вызвать `delete []` буффера, выделенного с помощью `new char[]`), либо остальные функции выкинули его (нужно вызвать деструктор и повторить шаги из предыдущего случая). Когда объектов много, то все случаи обработать трудно.

  * Обычно же нужно выделять массив под несколько элементов (когда пишем свой `vector`, например). Тогда эти объекты нужно в каком-то порядке создавать, или копировать массив объектов, тогда возникает куча проблем с тем что мы не имеем право использовать оператор присваивания. Нужно везде вызывать placement new, а если кто-нибудь выкинул исключение нужно все объекты удалить. А там могут быть или не быть требования к порядку удаления.

  * Можно это всё написать руками, а можно использовать такие функции как:

    * `std::uninitialized_default_construct(T* first, T* last)`, удаляет объекты в __неопределённом__ порядке. Устроена так: есть цикл, который  вызывает конструкторы по умолчанию. Если вылетает исключение, то он всё подчищает, все необходимые деструкторы вызывает и т.д.
    * `std::uninitialized_copy(T* first, T* last, T* out)`. Тоже вызывает деструкторы при выброшенном исключении. Устроена похожим образом, только вызываются  копирующие конструкторы, а не конструкторы по умолчанию.

* Вспомогательный  `stack_impl` для упрощения управления памятью с массивов объектов
  * Можно вместо встроенных функций `uninitialized_*` написать вспомогательный класс, поддерживающий количество созданных элементов и удаляющий всё необходимое в деструкторе. Как он примерно выглядит на примере лабы по вектору:

  ``` C++
  struct my_vector_holder final {
    std::size_t
      _cap,
      _len; // _len обновляем при добавлении нового элемента
    T *_data;
    my_vector_holder() noexcept; // просто обнуляем все поля
    my_vector_holder(std::size_t cap); // выделяем память в _data
    my_vector_holder(const my_vector_holder &) = delete;
    my_vector_holder & operator=(const my_vector_holder &) = delete;
    ~my_vector_holder(); // вызываем _len деструкторов и делаем delete [] _data
  };
  ```
