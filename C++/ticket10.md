## Билет 10 "Исключения — детали"
Автор: Егор Лебедев
### Исключения, вылетающие из конструктора
В силу того, что у конструктора нет возвращаемого значения, ошибки возникшие на этапе создания объекта обычно обрабатываются с помощью исключений. Очень удобно, что если мы можем обратиться к переменной, то она всегда корректна (поскольку исключение кидается за фигурные скобочки, в которых переменная объявлена). Пример:
```c++
try {
    std::vector<int> a(178'000'000);
    ...
} catch (std::bad_alloc&) {
    ... // вектор уже не существует
}
... // вектор уже не существует
```

Отсюда идиома:

**RAII** - resource acquisition is initialization (получение ресурса есть инициализация): конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

* Исключения могут вылетать в теле конструктора, тут их они обрабатываются так, как это происходит обычно.


* Также исключения могут вылетать из member initializer list (поля, базовые классы). Тогда не совсем ясно, что можно с этим вообще сделать. Конечно, существует такой синтаксис, называется **function try block**:
    ```c++
    struct Foo {
        Foo() try
            : vec(31'000)
            , f(new int[238])
            , s(new int[31]) {
            // ...
        } catch (...) {
            // ...
            /* throw; */
        }
        std::vector<int> vec;
        int** f;
        int** s;
    };
    ```
    В такой реализации при вылетевшем из строки `s(new int[31])` исключении невозможно будет обратиться к `f`, так как она будет "мертва" уже в момент входа в `catch`. Решение: объекты с автоматическим управлением временем жизни, такие как вектор, у которого деструктор вызовется автоматически.

    _Замечание_: в конца такого блока `catch` всегда неявно будет дописываться `throw` (только в конструкторах).

* В отдельный случай можно выделить **делигирующие конструкторы**:
    ```c++
    struct Foo {
        Foo(int x) {
            some_operation_a(x); // (1)
        }
        Foo() : Foo(10) {
            some_operation_b();  // (2)
        }
        ~Foo() {}
    };
    ```
    1. Если вызвали `Foo(10)` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    2. Если вызвали `Foo()` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    3. Если вызвали `Foo()` (а в нем вызывался `Foo(10)`) и `(2)` выкинуло исключение,
   то __деструктор вызовется__.

* Везде лучше использовать RAII:
    ```c++
    new X(new Y); // Тут `X` начинает владеть `Y` и обязан его удалить, "очевидно".
    ```
    1. Если кинул конструктор `Y`, то утечек нет.
    2. Если кинул конструктор `X`, то утечек нет — он _может_ удалить переданный во владение `Y`.
    3. Если кинул исключение `new Y`, то утечек нет.
    4. А вот если исключение кинул `new X`, то **утекло** `new Y`. До конструктора `X` дело не дошло.

    Решение: `X` сам себе создает `Y`, или `unique_ptr`.

* _Замечание (не только для конструкторов)_: в таком коде
    ```c++
    try {
        T** arr = new T[238];  // 1
        ... // 2
    } catch (const std::bad_alloc&) {
    }
    ```
    если `1` бросит исключение, то утечки памяти не будет, поскольку new либо отработает корректно, либо отчистит всю память которую выделил и вызовет все деструкторы. Если же `2` кинет исключение - утечка памяти, поскольку к `arr` мы уже не сможем обратиться, чтобы вызвать оператор `delete`

_Замечание_ про function try block: он может использоваться не только в конструкторах, но его необходимость отсутствует, поскольку он заменяется на привычный try-catch блок. Пример (возможно, на экзамене не нужен):
```c++
int f(int n = 2) try {
   ++n;
   throw n;
} catch(...) {
   ++n; // n все еще видна как параметр функции
   assert(n == 4);
   return n;
   // throw НЕ дописывается неявно
}
```
### Исключения из деструктора
По умолчанию исключения из деструктора бросать **запрещено** (неявно дописан `noexcept`), иначе вызывается `std::terminate`. Причина: деструкторы активно вызываются в момент, когда поймано какое-то другое исключение и происходит раскрутка стека, поэтому не ясно, как с этим справляться, если вылетит еще одно исключение (из деструктора).

### Преимущества и недостатки
* Преимущества:
    * Потенциально меньше кода
    * Явное разделение нормальной работы программы и исправления ошибки
* Недостатки:
    * Время работы программы может пострадать
    * Требуют аккуратности с ресурсами

### Непойманные исключения
Непойманные исключени - аварийно завершают программу, при это возможно такое, что программа поймет, что исключение никто не поймает, и завершится **без** раскрутки стека.

Решение: ловить их (например, оборачивать `main` в `try-catch` блок).

Лично у меня такой код ничего не выводил:
```c++
struct sd {
    ~sd() { cout << "finally"; }
};

int main() {
    sd var;
    throw int();
}
```
